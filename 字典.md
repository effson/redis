## 源码
> src/dict.h dict.c
### 数据结构
```c
struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;     /* Next entry in the same hash bucket. */
};
```
```c
struct dict {
    dictType *type;

    dictEntry **ht_table[2];
    unsigned long ht_used[2];

    long rehashidx; /* rehashing not in progress if rehashidx == -1 */

    /* Keep small vars at end for optimal (minimal) struct padding */
    unsigned pauserehash : 15; /* If >0 rehashing is paused */

    unsigned useStoredKeyApi : 1; /* See comment of storedHashFunction above */
    signed char ht_size_exp[2]; /* exponent of size. (size = 1<<exp) */
    int16_t pauseAutoResize;  /* If >0 automatic resizing is disallowed (<0 indicates coding error) */
    void *metadata[];
};
```
#### 1. dictType *type
字典的类型指针。它指向一个包含一系列函数指针的 dictType 结构体，这些函数定义了字典的具体行为,这种设计使得 Redis 能够为不同类型的数据（如字符串键值对、哈希表、有序集合等）使用同一个 dict 构体，实现了多态性，大大提高了代码的通用性
```c
typedef struct dictType {
    /* Callbacks */
    uint64_t (*hashFunction)(const void *key);  // 哈希算法， 根据键值计算哈希值、索引值
    void *(*keyDup)(dict *d, const void *key);  // 复制键的函数
    void *(*valDup)(dict *d, const void *obj);  // 复制值的函数
    int (*keyCompare)(dict *d, const void *key1, const void *key2); // 对比键的函数
    void (*keyDestructor)(dict *d, void *key); // 释放键的内存
    void (*valDestructor)(dict *d, void *obj); // 释放值的内存
    int (*resizeAllowed)(size_t moreMem, double usedRatio);
    /* Invoked at the start of dict initialization/rehashing (old and new ht are already created) */
    void (*rehashingStarted)(dict *d);
    void (*rehashingCompleted)(dict *d);
    void (*bucketChanged)(dict *d, long long delta);
    size_t (*dictMetadataBytes)(dict *d);
    /* Data */
    void *userdata;
    unsigned int no_value:1;
    unsigned int keys_are_odd:1;

    uint64_t (*storedHashFunction)(const void *key);
    int (*storedKeyCompare)(dict *d, const void *key1, const void *key2);

    /* Optional callback called when the dict is destroyed. */
    void (*onDictRelease)(dict *d);
} dictType;
```

#### 2. dictEntry **ht_table[2]
字典的核心哈希表数组。它包含两个指向 dictEntry 指针数组的指针
- ht_table[0] 是主哈希表。正常情况下，所有键值对都存储在这个表中
- ht_table[1] 是备用哈希表。它只在进行渐进式 rehash（扩容或收缩）时使用。这种设计允许 Redis 将耗时较大的 rehash 操作分解为多次小的增量操作，从而避免在 rehash 过程中阻塞服务

#### 3. long rehashidx
渐进式 rehash 的索引。当 rehash 正在进行时，它记录了当前已经迁移到 ht_table[1] 的哈希桶位置。如果 rehashidx 的值为 -1，则表示字典当前没有在进行 rehash

#### 4. unsigned long ht_used[2]
这个数组记录了两个哈希表中各自已使用的键值对数量。ht_used[0] 记录主表的使用量，ht_used[1] 记录备用表的使用量。通过这两个值可以快速获取字典中的总键数

#### 5. unsigned pauserehash
位字段（bitfield），用作暂停 rehash 的计数器。
- pauserehash 的值大于 0 时，rehash 就会暂停。
- 通常在执行像 BGREWRITEAOF 这样对性能敏感的操作时被设置为大于 0，以防止 rehash 影响性能。操作完成后，这个计数器会减小，直到为 0 时 rehash 恢复

#### 6. signed char ht_size_exp[2]
一个非常节省空间的优化。由于 Redis 的哈希表大小总是 2 的幂，因此它不需要存储完整的 size，而只需要存储大小的指数。例如，如果哈希表大小是 16，那么指数就是 4（2 
^4 =16）
## 渐进式rehash
### 缩容触发条件
> /src/server.c  server.h
```c
#define DICT_HT_INITIAL_EXP      2
#define DICT_HT_INITIAL_SIZE     (1<<(DICT_HT_INITIAL_EXP))

#define HASHTABLE_MIN_FILL        10      /* Minimal hash table fill 10% */

int htNeedsResize(dict *dict) {
    long long size, used;

    size = dictSlots(dict);
    used = dictSize(dict);
    return (size > DICT_HT_INITIAL_SIZE &&
            (used*100/size < HASHTABLE_MIN_FILL));
}
```
<mark>size > 4 && used / size < 10%</mark> <br>
### 扩容触发条件
> /src/dict.c
```c
static int _dictExpandIfNeeded(dict *d)
{
    /* Incremental rehashing already in progress. Return. */
    if (dictIsRehashing(d)) return DICT_OK;

    /* If the hash table is empty expand it to the initial size. */
    if (DICTHT_SIZE(d->ht_size_exp[0]) == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);

    /* If we reached the 1:1 ratio, and we are allowed to resize the hash
     * table (global setting) or we should avoid it but the ratio between
     * elements/buckets is over the "safe" threshold, we resize doubling
     * the number of buckets. */
    if ((dict_can_resize == DICT_RESIZE_ENABLE &&
         d->ht_used[0] >= DICTHT_SIZE(d->ht_size_exp[0])) ||
        (dict_can_resize != DICT_RESIZE_FORBID &&
         d->ht_used[0] / DICTHT_SIZE(d->ht_size_exp[0]) > dict_force_resize_ratio))
    {
        if (!dictTypeExpandAllowed(d))
            return DICT_OK;
        return dictExpand(d, d->ht_used[0] + 1);
    }
    return DICT_OK;
}
```
### rehash

每一次增删查改迁移一个索引单位，在服务器空闲时最多会迁移1ms

<img width="320" height="73" alt="image" src="https://github.com/user-attachments/assets/137dbc82-3f74-41f1-8f5d-d1d6f6f2f096" />


### SCAN
增量迭代 key 空间，每次只做一点点工作（非阻塞），<mark>适合在生产环境遍历大量键</mark>。与 KEYS（一次性返回所有匹配键、可能阻塞）相比，SCAN 更安全、对延迟更友好

```css
SCAN cursor [MATCH pattern] [COUNT count] [TYPE type]
```

- cursor：游标，第一次传 0；返回结果里会给你一个新的游标；当返回的游标再次变为 "0"，表示本轮遍历结束。
- MATCH pattern：服务端通配匹配（*、?、[abc]、[a-z] 等），只返回匹配到的键。
- COUNT count：提示值，不是硬性数量；默认约 10。可调大以提高吞吐，如 100、1000。
- TYPE type：只扫描指定类型的键（如 string、hash、list、set、zset 等）<br>

<mark>不阻塞、可能重复/遗漏（数据在变更时），需要客户端去重与循环到游标回到 0 为止</mark>

#### 原理
SCAN 的游标是个无符号数（客户端第一次传 0 开始）。
- 服务器内部的扫描用到了经典的 “位反转（bit reversal）+ 自增” 技巧来“走桶”：
- 用 sizemask = size - 1（size 为 2 的幂）把游标映射到桶：bucket = cursor & sizemask；访问该桶上的链表节点；
- 位反转 → +1 → 再反转 得到下一个游标
- 当 哈希表扩容/缩容（size 变为 2 的幂的另一值） 时，旧游标映射到的新桶序列能与新表的桶序列自然交织，从而不漏桶（最多产生重复）
