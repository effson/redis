## 源码
### LPUSH / RPUSH / LPOP / LRANGE → List
### 数据结构
> src/adlist.h adlist.c
```c
typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;

typedef struct list {
    listNode *head;  // 表头节点
    listNode *tail;  // 表尾节点
    void *(*dup)(void *ptr); // 节点值复制函数
    void (*free)(void *ptr); // 节点值释放函数
    int (*match)(void *ptr, void *key); // 节点值对比函数
    unsigned long len; // 链表包含的节点数量
} list;
```

<img width="676" height="121" alt="image" src="https://github.com/user-attachments/assets/7ea4b0a5-1a30-443d-a794-c5c4d631e52d" />


### 操作函数

```c
list *listCreate(void);
void listRelease(list *list);
void listReleaseGeneric(void *list);
void listEmpty(list *list);
list *listAddNodeHead(list *list, void *value);
list *listAddNodeTail(list *list, void *value);
list *listInsertNode(list *list, listNode *old_node, void *value, int after);
void listDelNode(list *list, listNode *node);
listIter *listGetIterator(list *list, int direction);
listNode *listNext(listIter *iter);
void listReleaseIterator(listIter *iter);
list *listDup(list *orig);
listNode *listSearchKey(list *list, void *key);
listNode *listIndex(list *list, long index);
void listRewind(list *list, listIter *li);
void listRewindTail(list *list, listIter *li);
void listRotateTailToHead(list *list);
void listRotateHeadToTail(list *list);
void listJoin(list *l, list *o);
void listInitNode(listNode *node, void *value);
void listLinkNodeHead(list *list, listNode *node);
void listLinkNodeTail(list *list, listNode *node);
void listUnlinkNode(list *list, listNode *node);
```
### 
Redis 的 list 在底层会自动选择 listpack 编码，只要它满足**元素数量和总字节数**这两个阈值中的任一条件。当超出这些限制时，Redis 会将列表分割成多个节点，并将这些节点组织成一个 quicklist，每个节点内部依然是一个 listpack，从而在兼顾内存效率和性能的同时，避免了单一巨大列表带来的性能问题
