## 1.Redis是不是单线程
```bash
gdb src/redis-server
run redis.conf
```

<img width="1106" height="182" alt="image" src="https://github.com/user-attachments/assets/32a83d5a-dcfe-42e2-8f54-6c9c6ef8d7db" />


根据gdb调试结果，并不是单线程，除了主线程"redis-server"（停在 epoll_wait）外，还有这些线程：
#### bio_close_file
异步关闭大文件。场景：关闭很大的 RDB/AOF/临时文件、慢磁盘/NFS 情况下 close() 可能卡很久；主线程只把“关闭任务”丢到队列里立即返回，后台再真正 close(fd)
#### bio_aof
AOF fsync/刷盘。异步执行 AOF 的 fsync/fdatasync。appendonly yes 且 appendfsync everysec 时，主线程把数据写到 AOF 缓冲区并 write()，真正的刷盘交给
该线程每秒做一次；避免主线程被慢盘 fsync 卡住。若设为 appendfsync always，刷盘在主线程完成；no 则完全交给 OS（无此线程参与）
#### bio_lazy_free
异步释放大对象/大量内存，降低停顿。场景：UNLINK、FLUSHDB/FLUSHALL ASYNC、过期回收、驱逐、DEL（若开启 lazyfree 选项）等。主线程只把键从字典“摘链”，**真正的深度释放（free 子结构）**后台慢慢做，避免一次性 free() 导致长尾延迟。
#### io_thd_*
io多线程
#### jemalloc_bg_thd
jemalloc 的 后台清理线程（内存回收/归并）

### 单线程的含义
<mark>Redis 进程是多线程的（有后台/可选 I/O 线程），但命令执行模型是单线程</mark>
