## 1.Redis是不是单线程
```bash
gdb src/redis-server
run redis.conf
```

<img width="1106" height="182" alt="image" src="https://github.com/user-attachments/assets/32a83d5a-dcfe-42e2-8f54-6c9c6ef8d7db" />


根据gdb调试结果，并不是单线程，除了主线程"redis-server"（停在 epoll_wait）外，还有这些线程：
#### bio_close_file
异步关闭大文件。场景：关闭很大的 RDB/AOF/临时文件、慢磁盘/NFS 情况下 close() 可能卡很久；主线程只把“关闭任务”丢到队列里立即返回，后台再真正 close(fd)
#### bio_aof
AOF fsync/刷盘。异步执行 AOF 的 fsync/fdatasync。appendonly yes 且 appendfsync everysec 时，主线程把数据写到 AOF 缓冲区并 write()，真正的刷盘交给
该线程每秒做一次；避免主线程被慢盘 fsync 卡住。若设为 appendfsync always，刷盘在主线程完成；no 则完全交给 OS（无此线程参与）
#### bio_lazy_free
异步释放大对象/大量内存，降低停顿。场景：UNLINK、FLUSHDB/FLUSHALL ASYNC、过期回收、驱逐、DEL（若开启 lazyfree 选项）等。主线程只把键从字典“摘链”，**真正的深度释放（free 子结构）**后台慢慢做，避免一次性 free() 导致长尾延迟。
#### io_thd_*
io多线程
#### jemalloc_bg_thd
jemalloc 的 后台清理线程（内存回收/归并）

### 单线程的含义
<mark>Redis 进程是多线程的（有后台/可选 I/O 线程），但命令执行模型是单线程</mark>


## 2.命令处理为单线程
### 单线程执行的局限
- 不能有耗时操作，对大 key 的 O(N) 命令（如对巨大的 list/hash/zset 做全量操作）、长 Lua 脚本、阻塞型命令，都会阻塞后续请求
- 规避：SCAN 代替 KEYS、UNLINK 代替 DEL 大对象、FLUSHDB/ALL ASYNC、拆脚本、控制批量大小
- 同一时刻只有一条命令在跑，<mark>CPU-bound 和阻塞的io</mark>的工作无法并行

### 为什么不采用多线程
- 锁开销与复杂度：给字典、跳表、过期集合、各数据结构加锁，带来锁竞争、优先级反转、难以复现的时序 bug
- 频繁的cpu上下文切换，抵消多线程的优势

## 3.redisDb

```c
typedef struct redisDb {
    dict *dict;                 /* The keyspace for this DB */
    dict *expires;              /* Timeout of keys with a timeout set */
    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/
    dict *blocking_keys_unblock_on_nokey;   /* Keys with clients waiting for
                                             * data, and should be unblocked if key is deleted (XREADEDGROUP).
                                             * This is a subset of blocking_keys*/
    dict *ready_keys;           /* Blocked keys that received a PUSH */
    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */
    int id;                     /* Database ID */
    long long avg_ttl;          /* Average TTL, just for stats */
    unsigned long expires_cursor; /* Cursor of the active expire cycle. */
    list *defrag_later;         /* List of key names to attempt to defrag one by one, gradually. */
    clusterSlotToKeyMapping *slots_to_keys; /* Array of slots to keys. Only used in cluster mode (db 0). */
} redisDb;
```

## 4. Redis reactor网络模型
```bash
gdb src/redis-server
```
<img width="481" height="209" alt="image" src="https://github.com/user-attachments/assets/8ada3a30-43f3-42d9-acb5-e61976adc411" />

```bash
run redis.conf
```

<img width="728" height="508" alt="image" src="https://github.com/user-attachments/assets/c51ab824-f43b-48de-9fd6-7e904ad73fd7" />


### gdb跟踪
#### listenfd，接入（accept → create client）：
- acceptCommonHandler
- createClient ← 新连接转成 redis client 的入口

#### clientfd：
- readQueryFromClient

<img width="573" height="63" alt="image" src="https://github.com/user-attachments/assets/c654e46d-02ee-4854-a882-f3cdc2412574" />

<br>

<img width="329" height="32" alt="image" src="https://github.com/user-attachments/assets/05284917-d9ab-46e0-9709-73cc31d3e0b7" />

<br>

<img width="647" height="110" alt="image" src="https://github.com/user-attachments/assets/07f93109-c574-41b4-b0e1-13f8d7d5eeb7" />

<br>

<img width="646" height="254" alt="image" src="https://github.com/user-attachments/assets/cc72ca83-6922-4f13-a1b2-8123f08a7665" />

#### 客户端发送数据
根据源码，客户端发送数据会执行readQueryFromClient<br>

<img width="605" height="382" alt="image" src="https://github.com/user-attachments/assets/68924d24-5c7e-494f-806d-8ef1be7b224a" />

<br>

打断点并继续运行：

<img width="650" height="134" alt="image" src="https://github.com/user-attachments/assets/3b0a0ada-d0b8-40ab-8fb7-762959322b29" />

<br>

<img width="343" height="29" alt="image" src="https://github.com/user-attachments/assets/799707b1-05a2-4c92-8611-b9a6bc3369b3" />

<br>

客户端发送命令：<br>

<img width="331" height="32" alt="image" src="https://github.com/user-attachments/assets/d1295f25-ec3b-480f-9cd5-d05166947d4c" />

继续命中readQueryFromClient：<br>

<img width="649" height="191" alt="image" src="https://github.com/user-attachments/assets/19b0ca29-30e7-4328-8609-a81f317cf5bc" />

<br>

根据readQueryFromClient函数，对postponeClientRead打断点：<br>

<img width="601" height="229" alt="image" src="https://github.com/user-attachments/assets/2cc60340-b8ab-4662-b6c0-559046054040" />

<br>

<img width="541" height="317" alt="image" src="https://github.com/user-attachments/assets/d4fcb569-4717-42cd-b71f-7948f1d85257" />

<br>

<img width="651" height="124" alt="image" src="https://github.com/user-attachments/assets/cc78bf1d-b159-4494-a53e-9f1279f43f09" />
<br>

<img width="632" height="133" alt="image" src="https://github.com/user-attachments/assets/2a921e7a-796d-4edc-9133-b20e4c688c30" />
