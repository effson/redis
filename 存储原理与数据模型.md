## 1.Redis是不是单线程
```bash
gdb src/redis-server
run redis.conf
```

<img width="1106" height="182" alt="image" src="https://github.com/user-attachments/assets/32a83d5a-dcfe-42e2-8f54-6c9c6ef8d7db" />


根据gdb调试结果，并不是单线程，除了主线程"redis-server"（停在 epoll_wait）外，还有这些线程：
#### bio_close_file
异步关闭大文件。场景：关闭很大的 RDB/AOF/临时文件、慢磁盘/NFS 情况下 close() 可能卡很久；主线程只把“关闭任务”丢到队列里立即返回，后台再真正 close(fd)
#### bio_aof
AOF fsync/刷盘。异步执行 AOF 的 fsync/fdatasync。appendonly yes 且 appendfsync everysec 时，主线程把数据写到 AOF 缓冲区并 write()，真正的刷盘交给
该线程每秒做一次；避免主线程被慢盘 fsync 卡住。若设为 appendfsync always，刷盘在主线程完成；no 则完全交给 OS（无此线程参与）
#### bio_lazy_free
异步释放大对象/大量内存，降低停顿。场景：UNLINK、FLUSHDB/FLUSHALL ASYNC、过期回收、驱逐、DEL（若开启 lazyfree 选项）等。主线程只把键从字典“摘链”，**真正的深度释放（free 子结构）**后台慢慢做，避免一次性 free() 导致长尾延迟。
#### io_thd_*
io多线程
#### jemalloc_bg_thd
jemalloc 的 后台清理线程（内存回收/归并）

### 单线程的含义
<mark>Redis 进程是多线程的（有后台/可选 I/O 线程），但命令执行模型是单线程</mark>


## 2.命令处理为单线程
### 单线程执行的局限
- 不能有耗时操作，对大 key 的 O(N) 命令（如对巨大的 list/hash/zset 做全量操作）、长 Lua 脚本、阻塞型命令，都会阻塞后续请求
- 规避：SCAN 代替 KEYS、UNLINK 代替 DEL 大对象、FLUSHDB/ALL ASYNC、拆脚本、控制批量大小
- 同一时刻只有一条命令在跑，<mark>CPU-bound 和阻塞的io</mark>的工作无法并行

### 为什么不采用多线程
- 锁开销与复杂度：给字典、跳表、过期集合、各数据结构加锁，带来锁竞争、优先级反转、难以复现的时序 bug
- 频繁的cpu上下文切换，抵消多线程的优势

## 3.redisDb

```c
typedef struct redisDb {
    dict *dict;                 /* The keyspace for this DB */
    dict *expires;              /* Timeout of keys with a timeout set */
    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/
    dict *blocking_keys_unblock_on_nokey;   /* Keys with clients waiting for
                                             * data, and should be unblocked if key is deleted (XREADEDGROUP).
                                             * This is a subset of blocking_keys*/
    dict *ready_keys;           /* Blocked keys that received a PUSH */
    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */
    int id;                     /* Database ID */
    long long avg_ttl;          /* Average TTL, just for stats */
    unsigned long expires_cursor; /* Cursor of the active expire cycle. */
    list *defrag_later;         /* List of key names to attempt to defrag one by one, gradually. */
    clusterSlotToKeyMapping *slots_to_keys; /* Array of slots to keys. Only used in cluster mode (db 0). */
} redisDb;
```

## 4. Redis reactor网络模型
```bash
gdb src/redis-server
```
<img width="481" height="209" alt="image" src="https://github.com/user-attachments/assets/8ada3a30-43f3-42d9-acb5-e61976adc411" />

```bash
run redis.conf
```

<img width="728" height="508" alt="image" src="https://github.com/user-attachments/assets/c51ab824-f43b-48de-9fd6-7e904ad73fd7" />


### 添加关键断点
listenfd，接入（accept → create client）：
- acceptTcpHandler，读事件回调函数
- acceptCommonHandler
- createClient ← 新连接转成 redis client 的入口

<img width="573" height="63" alt="image" src="https://github.com/user-attachments/assets/c654e46d-02ee-4854-a882-f3cdc2412574" />

<br>
<img width="329" height="32" alt="image" src="https://github.com/user-attachments/assets/05284917-d9ab-46e0-9709-73cc31d3e0b7" />

<br>
<img width="647" height="110" alt="image" src="https://github.com/user-attachments/assets/07f93109-c574-41b4-b0e1-13f8d7d5eeb7" />

