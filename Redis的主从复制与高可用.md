## 1. Redis淘汰策略
### maxmemory
maxmemory 参数用于配置 Redis 实例可以使用的最大内存量。当 Redis 占用的内存超过这个限制时，就会触发内存淘汰机制或报错

### maxmemory-policy
maxmemory-policy 用于配置当 maxmemory 限制被触发时，Redis 应如何选择要淘汰的键（key）。不同的策略会影响数据淘汰的效率和准确性<br>

<mark>对过期KEY：</mark>
- volatile-lru：从设置了过期时间（EXPIRE）的键中，淘汰最近最少使用的KEY（Least Recently Used）
- volatile-lfu：从设置了过期时间的键中，淘汰最近使用频率最少的KEY（Least Frequently Used）
- volatile-ttl：只从设置了过期时间的键中，淘汰剩余生存时间（Time To Live, TTL）最短的KEY
- volatile-random：只从设置了过期时间的键中，随机淘汰

<mark>对全部KEY：</mark>
- allkeys-lru：从所有键中，淘汰最近最少使用的键
- allkeys-lfu：从所有键中，淘汰最近使用频率最少的键
- allkeys-random：从所有键中，随机淘汰

<mark>禁止淘汰：</mark>
- noeviction：不淘汰任何键。当达到内存上限时，所有写操作（如 SET, INCR）都会返回错误，但读操作（如 GET）仍然可用

### maxmemory-samples
maxmemory-samples 用于配置 LRU（最近最少使用）和 LFU（最不常用）算法的取样数量。因为要准确找出整个数据集中“最少使用”的键成本非常高，
所以 Redis 采用了一种近似算法。它会从数据集中随机抽取一定数量的键，然后从这些样本中选择最符合淘汰条件的键进行淘汰
- 作用：设置 LRU 或 LFU 算法的样本数
- 取值范围：通常在 3 到 10 之间。默认值为 5
- 样本数越大，淘汰算法的准确性就越高，越能淘汰掉真正的“最少使用”键

## 2. Redis的持久化
记录 Redis 服务器所执行的写命令来持久化数据
### AOF
AOF 持久化的整个流程大致可以分为三个步骤：<br>
- 命令追加 (Append)：当 Redis 服务器接收到一个写命令时，它会先执行这个命令，然后将该命令以 Redis 协议的格式追加到 AOF 缓冲区中。
- 文件写入 (Write)：Redis 会根据配置的同步策略（appendfsync）来决定何时将 AOF 缓冲区中的数据真正写入到磁盘上的 AOF 文件中。
- 文件同步 (Sync)：操作系统会将缓冲区中的数据同步到磁盘上，以确保数据不会在断电时丢失<br>

AOF 的三种同步策略 (appendfsync):<br>
- always：每收到一个写命令，就立即同步到磁盘,性能最差，因为每次写操作都会触发一次 fsync 系统调用，这会带来较大的磁盘 I/O 开销
- everysec：每秒钟同步一次,最多只会丢失一秒钟的数据
- no：不主动同步，由操作系统决定何时同步

AOF 的优点和缺点
- 数据持久性高：根据配置，可以做到非常高的数据安全性，例如 always 模式
- 日志可读性强：AOF 文件是文本格式，可以直接查看和理解，这对于数据恢复和排查问题非常有帮助
- 文件体积大：随着写命令的增多，AOF 文件会不断膨胀，可能占用大量磁盘空间
- 恢复速度慢：Redis 启动时需要重新执行 AOF 文件中的所有命令来重建数据，如果文件过大，这个过程会很慢


### RDB
RDB (Redis Database) 持久化方式，也叫快照（snapshot），是通过生成一个紧凑的、二进制格式的文件来持久化数据的。
周期性地将 Redis 内存中的所有数据，以一种高效的格式，写入到磁盘上一个 .rdb 文件中

RDB 的工作流程:
- RDB 持久化通常是由 Redis 主进程的子进程来完成的，以避免阻塞主进程
- Redis 主进程会调用 fork() 系统调用，创建一个子进程。此时，父子进程共享相同的内存,写时复制
- 子进程写入快照：子进程在不影响主进程继续处理请求的情况下，遍历 Redis 内存中的所有数据，将它们以 RDB 格式（一种高度压缩的二进制格式）写入到一个临时的 .rdb 文件中
- 原子性替换：当子进程完成文件写入后，它会向主进程发送一个信号。主进程收到信号后，会用这个新的临时 .rdb 文件原子性地替换掉旧的 .rdb 文件

RDB 的优点和缺点:
- 文件紧凑、体积小：RDB 文件是经过高度压缩的二进制格式，比 AOF 文件小得多，更适合用于数据备份和灾难恢复
- 恢复速度快：Redis 启动时加载 RDB 文件，因为是二进制格式，加载速度非常快，这对于快速恢复服务至关重要
- 性能高：Redis 父进程在生成 RDB 快照时只负责 fork 子进程，之后的所有工作都由子进程完成，不会对主进程造成性能影响，
- 避免阻塞主进程：Redis 是单线程模型，如果持久化操作（遍历内存数据并写入磁盘）在主进程中执行，会长时间阻塞，导致无法响应客户端请求。通过 fork() 创建子进程，持久化任务完全交给子进程去完成，主进程可以继续处理命令，从而保证了 Redis 的高可用性
- 主进程接收到新的写命令时，会触发写时复制，只对被修改的内存页进行拷贝。这显著减少了内存开销，因为并非所有数据都会在持久化期间被修改
- 数据丢失风险：由于 RDB 是周期性快照，而不是实时记录，所以如果 Redis 在两次快照之间崩溃，这期间的数据将会全部丢失

### AOF-Rewrite
- 派生子进程：Redis 主进程会调用 fork() 系统调用，创建一个子进程。这样做的好处是，主进程可以继续正常处理客户端请求，而子进程则负责执行重写任务，二者互不影响
- 子进程生成新的 AOF 文件：子进程开始遍历 Redis 内存中的所有数据。它不关心旧的 AOF 文件内容，而是直接以命令序列的形式，将能够恢复当前数据库状态的最少命令集写入一个新的临时 AOF 文件中。例如，如果一个键经过多次操作，子进程只会写入最终状态的 SET 命令
- 增量同步：在子进程执行重写的整个过程中，主进程依然在接收和处理新的写命令。为了保证数据一致性，主进程会将所有新接收到的写命令追加到一个AOF 重写缓冲区中。这个缓冲区是独立于主 AOF 缓冲区的
- 信号与缓冲区追加：当子进程完成了所有数据的写入后，它会向主进程发送一个完成信号。主进程收到信号后，会将 AOF 重写缓冲区中的所有命令，追加到子进程生成的新 AOF 文件的末尾。这个过程会阻塞主进程，但由于重写缓冲区通常很小，阻塞时间非常短
- 原子性替换：当新文件包含了所有数据（快照数据 + 增量数据）后，Redis 主进程会用这个新文件原子性地替换掉旧的 AOF 文件。这意味着在替换完成之前，旧文件始终有效，不会出现新旧文件同时存在或不完整的情况

### AOF-RDB
与AOF-Rewrite的区别：
- 子进程不会遍历内存生成 AOF 命令，而是直接将内存中的数据以紧凑的、二进制的 RDB 格式写入一个临时文件中
- 合并 AOF 增量命令：子进程完成了 RDB 文件生成后，向主进程发送一个信号。主进程会将 AOF 重写缓冲区中的所有增量命令，以 AOF 格式追加到子进程生成的临时 RDB 文件的末尾。临时文件就包含了一个 RDB 快照 + 一系列 AOF 命令
