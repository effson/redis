## 跳表在 Redis 的用途
跳表（zskiplist）是 Sorted Set（有序集合，Zset）的一种底层实现。Zset 有两个底层结构：
- ziplist / listpack（紧凑列表），旧版本是 ziplist，从 Redis 7 开始用 listpack 替代。当元素少（zset-max-listpack-entries，默认 128）且成员字符串较短（zset-max-listpack-value，默认 64字节），会用这种节省内存的紧凑结构
- skiplist + dict（跳表 + 哈希表），


<img width="1074" height="101" alt="image" src="https://github.com/user-attachments/assets/deba09c4-5bac-4381-9003-753643dfc4e4" />


## 源码
> src/server.h
```c
/* ZSETs use a specialized version of Skiplists */
typedef struct zskiplistNode {
    sds ele;                    // 成员值（字符串，SDS）
    double score;               // 分值（排序主键）
    struct zskiplistNode *backward; // 同层双向：指向前一个节点（level 1 的后退指针）
    struct zskiplistLevel {     // 多层“前进指针”+ span
        struct zskiplistNode *forward; // 这一层的下一个节点
        unsigned long span;            // 从当前节点到 forward 的“跨度”（用于 O(logN) 计 rank）
    } level[]; // 柔性数组：实际分配 level 个
} zskiplistNode;
```
要点：
- 排序规则：先按 score 升序；score 相等时按 ele 的字典序升序，保证全序一致性。
- span 的作用：维护“走到下一个前进节点跨过了多少个底层节点”，配合多层前进，支持 按排名定位(O(logN))
<br>

```c
typedef struct zskiplist {
    struct zskiplistNode *header, *tail; // 头/尾；header 是带最大层数的哨兵
    unsigned long length;                 // 节点总数（不含 header）
    int level;                            // 当前最高层数（>=1 && <= ZSKIPLIST_MAXLEVEL）
} zskiplist;
```
要点：
- header 不存数据，仅提供最多层的起跳位。
- level 是全表当前“最高层数”，插入/删除时会动态上升或收缩。
<br>

```c
typedef struct zset {
    dict *dict;
    zskiplist *zsl;
} zset;
```
要点,双结构并存：
- dict 提供 O(1) 按成员查找、更新分值；
- zsl 提供 有序遍历/范围查询/按名次查询 的 O(logN) 能力。
- 小数据量时用 listpack（紧凑结构）；超过阈值或不满足条件时转换为 zset（dict+skiplist）。

## 跳跃表API

### zslInsert
将包含给定成员和分值的新节点插入到跳跃表中
```c
zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned long rank[ZSKIPLIST_MAXLEVEL];
    int i, level;

    serverAssert(!isnan(score));
    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        /* store rank that is crossed to reach the insert position */
        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];
        while (x->level[i].forward &&
                (x->level[i].forward->score < score ||
                    (x->level[i].forward->score == score &&
                    sdscmp(x->level[i].forward->ele,ele) < 0)))
        {
            rank[i] += x->level[i].span;
            x = x->level[i].forward;
        }
        update[i] = x;
    }
    level = zslRandomLevel();
    if (level > zsl->level) {
        for (i = zsl->level; i < level; i++) {
            rank[i] = 0;
            update[i] = zsl->header;
            update[i]->level[i].span = zsl->length;
        }
        zsl->level = level;
    }
    x = zslCreateNode(level,score,ele);
    for (i = 0; i < level; i++) {
        x->level[i].forward = update[i]->level[i].forward;
        update[i]->level[i].forward = x;

        /* update span covered by update[i] as x is inserted here */
        x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]);
        update[i]->level[i].span = (rank[0] - rank[i]) + 1;
    }

    /* increment span for untouched levels */
    for (i = level; i < zsl->level; i++) {
        update[i]->level[i].span++;
    }

    x->backward = (update[0] == zsl->header) ? NULL : update[0];
    if (x->level[0].forward)
        x->level[0].forward->backward = x;
    else
        zsl->tail = x;
    zsl->length++;
    return x;
}
```
## listpack
### 源码
```c
typedef struct {
    /* When string is used, it is provided with the length (slen). */
    unsigned char *sval;
    uint32_t slen;
    /* When integer is used, 'sval' is NULL, and lval holds the value. */
    long long lval;
} listpackEntry;
```

<br>

```css
[ total-bytes(4字节LE) ][ num-elems(2字节LE) ][ entry1 ][ entry2 ] ... [ 0xFF ]
```
头部 6 字节：total-bytes(32-bit) 与 num-elems(16-bit；超过上限时写为 UINT16_MAX 表示“未知”，需要扫描计算)

```c
#define LP_HDR_SIZE 6       /* 32 bit total len + 16 bit number of elements. */
```

```c
#define lpSetTotalBytes(p,v) do { \
    (p)[0] = (v)&0xff; \
    (p)[1] = ((v)>>8)&0xff; \
    (p)[2] = ((v)>>16)&0xff; \
    (p)[3] = ((v)>>24)&0xff; \
} while(0)
```

```c
#define lpGetTotalBytes(p)           (((uint32_t)(p)[0]<<0) | \
                                      ((uint32_t)(p)[1]<<8) | \
                                      ((uint32_t)(p)[2]<<16) | \
                                      ((uint32_t)(p)[3]<<24))
```
                                                           
```c
#define lpGetNumElements(p)          (((uint32_t)(p)[4]<<0) | \
                                      ((uint32_t)(p)[5]<<8))
```
