## 技术拆解
### 1. 与Redis建立连接
- 创建socket，设置fd为非阻塞
- 调用connect，返回-1，并且errno=EINPROGRESS，表明该套接字为非阻塞套接字，连接无法立即完成，正在处理中
- fd注册到epoll中，注册写事件
- 如果连接建立成功，fd的写事件进行响应，注销写事件

### 2. 向Redis发送数据
- 使用Redis协议加密
- int n = write(fd, buf, sz); if n < sz && n != -1(或 n == -1， errno = EWOULDBLOCK), 说明fd的发送缓冲区已满，注册写事件，让epoll监视是否有多余缓冲区，将剩余数据发送出去
- 如果已全部发送，注册读事件
### 3. 读取Redis返回
- 读事件触发， int n = read(fd, buf, sz);
- 根据Redis分割数据包

<img width="1124" height="405" alt="image" src="https://github.com/user-attachments/assets/d73b02b6-3045-436c-a69a-4dc8d336e05a" />



## 编译执行

```bash
gcc -I. chainbuffer/chainbuffer.c redis_test_async.c reactor.c -o redis-test-async -lhiredis
```

## 测试结果
### 同步时延结果
发送1000条命令：

<img width="304" height="16" alt="image" src="https://github.com/user-attachments/assets/1560df62-f466-4dc3-8540-1e7a76e771f8" />

### 异步时延结果
发送1000条命令：

<img width="263" height="20" alt="image" src="https://github.com/user-attachments/assets/cb14d1e1-cf7d-415f-8496-535a2dc5e1d5" />
